## API Report File for "@svta/cml-608"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { ValueOf } from '@svta/cml-utils/ValueOf.js';

// @beta
export type CaptionModes = 'MODE_ROLL-UP' | 'MODE_POP-ON' | 'MODE_PAINT-ON' | 'MODE_TEXT' | null;

// @beta
export class CaptionScreen {
    constructor(logger?: CaptionsLogger);
    // (undocumented)
    backSpace(): void;
    // (undocumented)
    clearToEndOfRow(): void;
    // (undocumented)
    copy(other: CaptionScreen): void;
    // (undocumented)
    equals(other: CaptionScreen): boolean;
    getDisplayText(asOneRow?: boolean): string;
    // (undocumented)
    getTextAndFormat(): Row[];
    insertChar(char: number): void;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    moveCursor(relPos: number): void;
    // (undocumented)
    reset(): void;
    // (undocumented)
    rollUp(): void;
    // (undocumented)
    rows: Row[];
    setBkgData(bkgData: Partial<PenStyles>): void;
    // (undocumented)
    setCursor(absPos: number): void;
    // (undocumented)
    setPAC(pacData: PACData): void;
    // (undocumented)
    setPen(styles: Partial<PenStyles>): void;
    // (undocumented)
    setRollUpRows(nrRows: number | null): void;
}

// @beta
export class CaptionsLogger {
    // (undocumented)
    log(severity: VerboseLevel, msg: string | (() => string)): void;
    // (undocumented)
    time: number | null;
    // (undocumented)
    verboseLevel: VerboseLevel;
}

// @beta
export class Cta608Channel {
    constructor(channelNumber: number, outputFilter: CueHandler, logger?: CaptionsLogger);
    // (undocumented)
    ccAOF(): void;
    // (undocumented)
    ccAON(): void;
    // (undocumented)
    ccBS(): void;
    // (undocumented)
    ccCR(): void;
    // (undocumented)
    ccDER(): void;
    // (undocumented)
    ccEDM(): void;
    // (undocumented)
    ccENM(): void;
    // (undocumented)
    ccEOC(): void;
    // (undocumented)
    ccFON(): void;
    // (undocumented)
    ccMIDROW(secondByte: number): void;
    // (undocumented)
    ccRCL(): void;
    // (undocumented)
    ccRDC(): void;
    // (undocumented)
    ccRTD(): void;
    // (undocumented)
    ccRU(nrRows: number | null): void;
    // (undocumented)
    ccTO(nrCols: number): void;
    // (undocumented)
    ccTR(): void;
    // (undocumented)
    chNr: number;
    // (undocumented)
    cueSplitAtTime(t: number): void;
    // (undocumented)
    cueStartTime: number | null;
    // (undocumented)
    currRollUpRow: Row;
    // (undocumented)
    displayedMemory: CaptionScreen;
    // (undocumented)
    getHandler(): CueHandler;
    // (undocumented)
    insertChars(chars: number[]): void;
    // (undocumented)
    lastOutputScreen: CaptionScreen;
    // (undocumented)
    mode: CaptionModes;
    // (undocumented)
    nonDisplayedMemory: CaptionScreen;
    // (undocumented)
    outputDataUpdate(dispatch?: boolean): void;
    // (undocumented)
    outputFilter: CueHandler;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setBkgData(bkgData: Partial<PenStyles>): void;
    // (undocumented)
    setHandler(outputFilter: CueHandler): void;
    // (undocumented)
    setMode(newMode: CaptionModes): void;
    // (undocumented)
    setPAC(pacData: PACData): void;
    // (undocumented)
    writeScreen: CaptionScreen;
}

// @beta
export class Cta608Parser {
    constructor(field: SupportedField, out1: any, out2: any);
    addData(time: number | null, byteList: number[]): void;
    cueSplitAtTime(t: number): void;
    reset(): void;
}

// @beta
export type CueHandler = {
    newCue(startTime: number, endTime: number, screen: CaptionScreen): void;
    reset?(): void;
    dispatchCue?(): void;
};

// @beta
export function extractCta608Data(raw: DataView, cta608Range: Array<number>): Array<Array<number>>;

// @beta
export function findCta608Nalus(raw: DataView, startPos: number, size: number): Array<Array<number>>;

// @beta
export type PACData = {
    row: number;
    indent: number | null;
    color: string | null;
    underline: boolean;
    italics: boolean;
};

// @beta
export class PenState {
    // (undocumented)
    background: string;
    // (undocumented)
    copy(newPenState: PenState): void;
    // (undocumented)
    equals(other: PenState): boolean;
    // (undocumented)
    flash: boolean;
    // (undocumented)
    foreground: string;
    // (undocumented)
    isDefault(): boolean;
    // (undocumented)
    italics: boolean;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setStyles(styles: Partial<PenStyles>): void;
    // (undocumented)
    underline: boolean;
}

// @beta
export type PenStyles = {
    foreground: string | null;
    underline: boolean;
    italics: boolean;
    background: string;
    flash: boolean;
};

// @beta
export class Row {
    constructor(logger?: CaptionsLogger);
    backSpace(): void;
    // (undocumented)
    chars: StyledUnicodeChar[];
    // (undocumented)
    clear(): void;
    // (undocumented)
    clearFromPos(startPos: number): void;
    // (undocumented)
    clearToEndOfRow(): void;
    // (undocumented)
    copy(other: Row): void;
    // (undocumented)
    cueStartTime: number | null;
    // (undocumented)
    equals(other: Row): boolean;
    // (undocumented)
    getTextString(): string;
    // (undocumented)
    insertChar(byte: number): void;
    // (undocumented)
    isEmpty(): boolean;
    moveCursor(relPos: number): void;
    setCursor(absPos: number): void;
    // (undocumented)
    setPenStyles(styles: Partial<PenStyles>): void;
}

// @beta
export class SccParser {
    constructor(processor: any, field?: number | any);
    // (undocumented)
    field: number | any;
    // (undocumented)
    getField(): number | any;
    // (undocumented)
    getHeaderStatus(): boolean;
    // (undocumented)
    getLinesParsed(): number;
    // (undocumented)
    hasHeader: boolean;
    // (undocumented)
    nrLinesParsed: number;
    // (undocumented)
    parse(text: string): void;
    // (undocumented)
    parseDataLine(line: string): [number, number[]] | null;
    // (undocumented)
    processor: any;
    // (undocumented)
    timeConverter(smpteTs: string): number;
}

// @beta
export class StyledUnicodeChar {
    // (undocumented)
    copy(newChar: StyledUnicodeChar): void;
    // (undocumented)
    equals(other: StyledUnicodeChar): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    penState: PenState;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setChar(uchar: string, newPenState: PenState): void;
    // (undocumented)
    setPenState(newPenState: PenState): void;
    // (undocumented)
    uchar: string;
}

// @beta
export type SupportedField = 1 | 3;

// @beta
export const VerboseLevel: {
    readonly ERROR: 0;
    readonly TEXT: 1;
    readonly WARNING: 2;
    readonly INFO: 2;
    readonly DEBUG: 3;
    readonly DATA: 3;
};

// @beta (undocumented)
export type VerboseLevel = ValueOf<typeof VerboseLevel>;

```
