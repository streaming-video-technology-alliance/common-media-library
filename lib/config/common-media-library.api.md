## API Report File for "@svta/common-media-library"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @alpha
export type AdaptationSet = {
    $: {
        audioSamplingRate?: string;
        codecs?: string;
        contentType?: string;
        frameRate?: string;
        group?: string;
        id?: string;
        lang?: string;
        maxBandwidth?: string;
        maxFrameRate?: string;
        maxHeight?: string;
        maxWidth?: string;
        mimeType?: string;
        minBandwidth?: string;
        par?: string;
        sar?: string;
        segmentAlignment: string;
        startWithSAP?: string;
        subsegmentAlignment?: string;
        subsegmentStartsWithSAP?: string;
    };
    AudioChannelConfiguration?: AudioChannelConfiguration[];
    ContentComponent?: ContentComponent[];
    Role?: Role[];
    Representation: Representation[];
    SegmentTemplate?: SegmentTemplate[];
    SegmentList?: SegmentList[];
};

// @alpha
export type AlignedSwitchingSet = {
    switchingSets: SwitchingSet[];
};

// @beta
export function appendCmcdHeaders(headers: Record<string, string>, cmcd: Cmcd, options?: CmcdEncodeOptions): Record<string, string>;

// @beta
export function appendCmcdQuery(url: string, cmcd: Cmcd, options?: CmcdEncodeOptions): string;

// @beta
export function ardi(view: IsoView): Fields<AudioRenderingIndicationBox>;

// @beta
export class ArithmeticMeanEstimator implements ThroughputEstimator {
    // (undocumented)
    getEstimate(): number;
    // (undocumented)
    sample(sample: ResourceTiming): void;
}

// @beta
export function arrayBufferToString(arrayBuffer: ArrayBuffer, encoding: Encoding): string;

// @alpha
export type AudioChannelConfiguration = {
    $: {
        schemeIdUri: string;
        value: string;
    };
};

// @beta
export type AudioRenderingIndicationBox = FullBox & {
    type: 'ardi';
    audioRenderingIndication: number;
};

// @beta
export type AudioSampleEntryBox<T extends 'mp4a' | 'enca' = 'mp4a' | 'enca'> = SampleEntryBox & {
    type: T;
    reserved2: number[];
    channelcount: number;
    samplesize: number;
    preDefined: number;
    reserved3: number;
    samplerate: number;
    esds: Uint8Array;
};

// @alpha
export type AudioTrack = Track & {
    sampleRate: number;
    channels: number;
};

// @beta
export function avc1(view: IsoView): Fields<VisualSampleEntryBox<'avc1'>>;

// @beta
export function avc2(view: IsoView): Fields<VisualSampleEntryBox<'avc2'>>;

// @beta
export function avc3(view: IsoView): Fields<VisualSampleEntryBox<'avc3'>>;

// @beta
export function avc4(view: IsoView): Fields<VisualSampleEntryBox<'avc4'>>;

// @beta @deprecated
export function base64decode(str: string): Uint8Array;

// @beta @deprecated
export function base64encode(binary: Uint8Array): string;

// @beta
export type Box = {
    type: string;
    size: number;
    view: IsoView;
    largesize?: number;
    usertype?: number[];
};

// @beta
export type BoxFilter<T extends IsoBmffBox> = ((box: IsoBmffBox) => boolean) | ((box: IsoBmffBox) => box is T);

// @beta
export type BoxParser<V = IsoBox> = (view: IsoView, config?: IsoViewConfig) => Fields<V>;

// @beta
export type BoxParserMap = Record<string, BoxParser>;

// @alpha
export type Byterange = {
    length: number;
    offset: number;
};

// @beta
export function canParseId3(data: Uint8Array, offset: number): boolean;

// @beta
export type CaptionModes = 'MODE_ROLL-UP' | 'MODE_POP-ON' | 'MODE_PAINT-ON' | 'MODE_TEXT' | null;

// @beta
export class CaptionScreen {
    constructor(logger?: CaptionsLogger);
    // (undocumented)
    backSpace(): void;
    // (undocumented)
    clearToEndOfRow(): void;
    // (undocumented)
    copy(other: CaptionScreen): void;
    // (undocumented)
    equals(other: CaptionScreen): boolean;
    getDisplayText(asOneRow?: boolean): string;
    // (undocumented)
    getTextAndFormat(): Row[];
    insertChar(char: number): void;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    moveCursor(relPos: number): void;
    // (undocumented)
    reset(): void;
    // (undocumented)
    rollUp(): void;
    // (undocumented)
    rows: Row[];
    setBkgData(bkgData: Partial<PenStyles>): void;
    // (undocumented)
    setCursor(absPos: number): void;
    // (undocumented)
    setPAC(pacData: PACData): void;
    // (undocumented)
    setPen(styles: Partial<PenStyles>): void;
    // (undocumented)
    setRollUpRows(nrRows: number | null): void;
}

// @beta
export class CaptionsLogger {
    // (undocumented)
    log(severity: VerboseLevel, msg: string | (() => string)): void;
    // (undocumented)
    time: number | null;
    // (undocumented)
    verboseLevel: VerboseLevel;
}

// @beta
export const CBCS = "cbcs";

// @beta
export const CENC = "cenc";

// @beta
export const CHALLENGE = "Challenge";

// @beta
export type ChunkLargeOffsetBox = FullBox & {
    type: 'co64';
    entryCount: number;
    chunkOffset: number[];
};

// @beta
export type ChunkOffsetBox = FullBox & {
    type: 'stco';
    entryCount: number;
    chunkOffset: number[];
};

// @beta
export const CLEAR_KEY_SYSTEM = "org.w3.clearkey";

// @beta
export const CLEAR_KEY_UUID = "e2719d58-a985-b3c9-781a-b030af78d30e";

// @beta
export type Cmcd = {
    [index: CmcdCustomKey]: CmcdValue;
    br?: number;
    d?: number;
    ot?: CmcdObjectType;
    tb?: number;
    bl?: number;
    dl?: number;
    mtp?: number;
    nor?: string;
    nrr?: string;
    su?: boolean;
    cid?: string;
    pr?: number;
    sf?: CmcdStreamingFormat;
    sid?: string;
    st?: CmcdStreamType;
    v?: number;
    bs?: boolean;
    rtp?: number;
};

// @beta
export const CMCD_COMMON_KEYS: readonly ["ab", "bg", "bl", "br", "bs", "cdn", "cid", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pt", "pr", "sf", "sid", "sta", "st", "tab", "tb", "tbl", "tpb", "ts", "v", "cs", "df", "bsd", "sn"];

// @beta
export const CMCD_DEFAULT_TIME_INTERVAL = 30;

// @beta
export const CMCD_EVENT_KEYS: readonly ["e"];

// @beta
export const CMCD_EVENT_MODE = "event";

// @beta
export const CMCD_HEADERS = "headers";

// @beta
export const CMCD_JSON = "json";

// @beta
export const CMCD_OBJECT = "CMCD-Object";

// @beta
export const CMCD_PARAM = "CMCD";

// @beta
export const CMCD_QUERY = "query";

// @beta
export const CMCD_REQUEST = "CMCD-Request";

// @beta
export const CMCD_REQUEST_KEYS: readonly ["d", "dl", "nor", "ot", "rtp", "su"];

// @beta
export const CMCD_REQUEST_MODE = "request";

// @beta
export const CMCD_RESPONSE_KEYS: readonly ["rc", "ttfb", "ttfbb", "ttlb", "url", "cmsdd", "cmsds", "smrt"];

// @beta
export const CMCD_RESPONSE_MODE = "response";

// @beta
export const CMCD_SESSION = "CMCD-Session";

// @beta
export const CMCD_STATUS = "CMCD-Status";

// @beta
export const CMCD_V1 = 1;

// @beta
export const CMCD_V1_KEYS: readonly ["br", "d", "ot", "tb", "bl", "dl", "mtp", "nor", "nrr", "su", "bs", "rtp", "cid", "pr", "sf", "sid", "st", "v"];

// @beta
export const CMCD_V2 = 2;

// @beta
export type CmcdCustomKey = `${string}-${string}`;

// @beta
export type CmcdData = Cmcd & CmcdRequest & CmcdEvent & CmcdResponse;

// @beta
export type CmcdEncodeOptions = {
    formatters?: Record<CmcdKey, CmcdFormatter>;
    customHeaderMap?: CmcdHeadersMap;
    filter?: (key: CmcdKey) => boolean;
    baseUrl?: string;
};

// @beta
export const CmcdEncoding: {
    readonly JSON: typeof CMCD_JSON;
    readonly QUERY: typeof CMCD_QUERY;
    readonly HEADERS: typeof CMCD_HEADERS;
};

// @beta (undocumented)
export type CmcdEncoding = ValueOf<typeof CmcdEncoding>;

// Warning: (ae-forgotten-export) The symbol "CmcdEventExcludedKeys" needs to be exported by the entry point index.d.ts
//
// @beta
export type CmcdEvent = Omit<CmcdRequest, CmcdEventExcludedKeys> & {
    e?: CmcdEventType;
};

// @beta
export const CmcdEventType: {
    readonly PLAY_STATE: "ps";
    readonly ERROR: "e";
    readonly TIME_INTERVAL: "t";
    readonly CONTENT_ID: "c";
    readonly BACKGROUNDED_MODE: "b";
    readonly MUTE: "m";
    readonly UNMUTE: "um";
    readonly PLAYER_EXPAND: "pe";
    readonly PLAYER_COLLAPSE: "pc";
};

// @beta (undocumented)
export type CmcdEventType = ValueOf<typeof CmcdEventType>;

// @beta
export type CmcdFormatter = (value: CmcdValue, options?: CmcdEncodeOptions) => string | number;

// @beta
export const CmcdFormatters: Record<string, CmcdFormatter>;

// @beta
export const CmcdHeaderField: {
    readonly OBJECT: typeof CMCD_OBJECT;
    readonly REQUEST: typeof CMCD_REQUEST;
    readonly SESSION: typeof CMCD_SESSION;
    readonly STATUS: typeof CMCD_STATUS;
};

// @beta (undocumented)
export type CmcdHeaderField = ValueOf<typeof CmcdHeaderField>;

// @beta
export type CmcdHeadersMap = Record<CmcdHeaderField, CmcdKey[]>;

// @beta
export type CmcdKey = keyof CmcdData;

// @beta
export const CmcdMode: {
    readonly REQUEST: typeof CMCD_REQUEST_MODE;
    readonly RESPONSE: typeof CMCD_RESPONSE_MODE;
    readonly EVENT: typeof CMCD_EVENT_MODE;
};

// @beta (undocumented)
export type CmcdMode = ValueOf<typeof CmcdMode>;

// Warning: (ae-forgotten-export) The symbol "CmObjectType" needs to be exported by the entry point index.d.ts
//
// @beta
export const CmcdObjectType: typeof CmObjectType;

// @beta (undocumented)
export type CmcdObjectType = CmObjectType;

// @beta
export const CmcdPlayerState: {
    readonly STARTING: "s";
    readonly PLAYING: "p";
    readonly SEEKING: "k";
    readonly REBUFFERING: "r";
    readonly PAUSED: "a";
    readonly WAITING: "w";
    readonly ENDED: "e";
    readonly FATAL_ERROR: "f";
};

// @beta (undocumented)
export type CmcdPlayerState = ValueOf<typeof CmcdPlayerState>;

// @beta
export type CmcdRequest = Omit<Cmcd, 'nrr'> & {
    ab?: number;
    tbl?: number;
    cdn?: string;
    ltc?: number;
    bg?: boolean;
    sta?: CmcdPlayerState;
    pb?: number;
    ts?: number;
    tpb?: number;
    lb?: number;
    tab?: number;
    lab?: number;
    pt?: number;
    ec?: string | string[];
    msd?: number;
    sn?: number;
    bsd?: number;
    df?: number;
    cs?: number;
};

// @beta
export type CmcdResponse = CmcdRequest & {
    rc?: number;
    ttfb?: number;
    ttfbb?: number;
    ttlb?: number;
    url?: string;
    cmsdd?: string;
    cmsds?: string;
    smrt?: number;
};

// Warning: (ae-forgotten-export) The symbol "CmStreamingFormat" needs to be exported by the entry point index.d.ts
//
// @beta
export const CmcdStreamingFormat: typeof CmStreamingFormat;

// @beta (undocumented)
export type CmcdStreamingFormat = CmStreamingFormat;

// Warning: (ae-forgotten-export) The symbol "CmStreamType" needs to be exported by the entry point index.d.ts
//
// @beta
export const CmcdStreamType: typeof CmStreamType;

// @beta (undocumented)
export type CmcdStreamType = CmStreamType;

// @beta
export type CmcdValue = CmcdObjectType | CmcdStreamingFormat | CmcdStreamType | string | number | boolean | symbol | SfToken;

// Warning: (ae-internal-missing-underscore) The name "CmCustomKey" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type CmCustomKey = `${string}-${string}`;

// @beta
export const CMSD_DYNAMIC = "CMSD-Dynamic";

// @beta
export const CMSD_STATIC = "CMSD-Static";

// @beta
export const CMSD_V1 = 1;

// @beta
export type CmsdCustomKey = `${string}-${string}`;

// @beta
export type CmsdDynamic = {
    value: string;
    params: CmsdDynamicParams;
};

// @beta
export type CmsdDynamicParams = {
    [index: CmsdCustomKey]: CmsdValue;
    du?: boolean;
    etp?: number;
    mb?: number;
    rd?: number;
    rtt?: number;
};

// @beta
export type CmsdEncodeOptions = {
    useSymbol?: boolean;
};

// @beta
export const CmsdHeaderField: {
    readonly STATIC: typeof CMSD_STATIC;
    readonly DYNAMIC: typeof CMSD_DYNAMIC;
};

// @beta (undocumented)
export type CmsdHeaderField = ValueOf<typeof CmsdHeaderField>;

// @beta
export const CmsdObjectType: typeof CmObjectType;

// @beta (undocumented)
export type CmsdObjectType = CmObjectType;

// @beta
export type CmsdStatic = {
    [index: CmsdCustomKey]: CmsdValue;
    at?: number;
    br?: number;
    d?: number;
    ht?: number;
    n?: string;
    nor?: string;
    nrr?: string;
    ot?: CmsdObjectType;
    sf?: CmsdStreamingFormat;
    st?: CmsdStreamType;
    su?: boolean;
    v?: number;
};

// @beta
export const CmsdStreamingFormat: typeof CmStreamingFormat;

// @beta (undocumented)
export type CmsdStreamingFormat = CmStreamingFormat;

// @beta
export const CmsdStreamType: typeof CmStreamType;

// @beta (undocumented)
export type CmsdStreamType = CmStreamType;

// @beta
export type CmsdValue = CmsdObjectType | CmsdStreamingFormat | CmsdStreamType | string | number | boolean | symbol | SfToken;

// Warning: (ae-internal-missing-underscore) The name "CmValue" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type CmValue = CmObjectType | CmStreamingFormat | CmStreamType | string | number | boolean | symbol | SfToken;

// @beta
export type CommonMediaRequest = {
    url: string;
    method?: string;
    body?: BodyInit;
    responseType?: RequestType;
    headers?: Record<string, string>;
    credentials?: RequestCredentials;
    mode?: RequestMode;
    timeout?: number;
    cmcd?: Cmcd;
    customData?: any;
};

// @beta
export type CommonMediaResponse<R extends CommonMediaRequest = CommonMediaRequest> = {
    request: R;
    url?: string;
    redirected?: boolean;
    status?: number;
    statusText?: string;
    type?: string;
    headers?: Record<string, string>;
    data?: ResponseTypeMap<R['responseType']>;
    resourceTiming?: ResourceTiming;
};

// @beta
export type CompactSampleSizeBox = FullBox & {
    type: 'stz2';
    fieldSize: number;
    sampleCount: number;
    entrySize: number[];
};

// @beta
export type CompositionTimeToSampleBox = FullBox & {
    type: 'ctts';
    entryCount: number;
    entries: CompositionTimeToSampleEntry[];
};

// @beta
export type CompositionTimeToSampleEntry = {
    sampleCount: number;
    sampleOffset: number;
};

// @beta
export function concatInitDataIdAndCertificate(initData: Uint16Array, id: Uint16Array | string, cert: Uint8Array): Uint8Array;

// @beta
export type ContainerBox<T> = Box & {
    boxes: Array<T>;
};

// @beta
export const CONTENT_TYPE = "Content-Type";

// @alpha (undocumented)
export type ContentComponent = {
    $: {
        contentType: string;
        id: string;
    };
};

// @beta
export type ContentProtection = {
    schemeIdUri?: string;
    value?: string;
    pssh?: string;
    laUrl?: string;
};

// @beta
export function convertUint8ToUint16(input: Uint8Array): Uint16Array;

// @beta
export function createIsoView(raw: IsoData, config?: IsoViewConfig): IsoView;

// @beta
export function createMediaKeySystemConfiguration(supportedAudio: MediaKeySystemMediaCapability[] | null, supportedVideo: MediaKeySystemMediaCapability[] | null): MediaKeySystemConfiguration;

// @beta
export function createWebVttCue(): WebVttCue;

// @beta
export function createWebVttRegion(): WebVttRegion;

// @beta
export class Cta608Channel {
    constructor(channelNumber: number, outputFilter: CueHandler, logger?: CaptionsLogger);
    // (undocumented)
    ccAOF(): void;
    // (undocumented)
    ccAON(): void;
    // (undocumented)
    ccBS(): void;
    // (undocumented)
    ccCR(): void;
    // (undocumented)
    ccDER(): void;
    // (undocumented)
    ccEDM(): void;
    // (undocumented)
    ccENM(): void;
    // (undocumented)
    ccEOC(): void;
    // (undocumented)
    ccFON(): void;
    // (undocumented)
    ccMIDROW(secondByte: number): void;
    // (undocumented)
    ccRCL(): void;
    // (undocumented)
    ccRDC(): void;
    // (undocumented)
    ccRTD(): void;
    // (undocumented)
    ccRU(nrRows: number | null): void;
    // (undocumented)
    ccTO(nrCols: number): void;
    // (undocumented)
    ccTR(): void;
    // (undocumented)
    chNr: number;
    // (undocumented)
    cueSplitAtTime(t: number): void;
    // (undocumented)
    cueStartTime: number | null;
    // (undocumented)
    currRollUpRow: Row;
    // (undocumented)
    displayedMemory: CaptionScreen;
    // (undocumented)
    getHandler(): CueHandler;
    // (undocumented)
    insertChars(chars: number[]): void;
    // (undocumented)
    lastOutputScreen: CaptionScreen;
    // (undocumented)
    mode: CaptionModes;
    // (undocumented)
    nonDisplayedMemory: CaptionScreen;
    // (undocumented)
    outputDataUpdate(dispatch?: boolean): void;
    // (undocumented)
    outputFilter: CueHandler;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setBkgData(bkgData: Partial<PenStyles>): void;
    // (undocumented)
    setHandler(outputFilter: CueHandler): void;
    // (undocumented)
    setMode(newMode: CaptionModes): void;
    // (undocumented)
    setPAC(pacData: PACData): void;
    // (undocumented)
    writeScreen: CaptionScreen;
}

// @beta
export class Cta608Parser {
    constructor(field: SupportedField, out1: any, out2: any);
    addData(time: number | null, byteList: number[]): void;
    cueSplitAtTime(t: number): void;
    reset(): void;
}

// @beta
export function ctts(view: IsoView): Fields<CompositionTimeToSampleBox>;

// @beta
export type CueHandler = {
    newCue(startTime: number, endTime: number, screen: CaptionScreen): void;
    reset?(): void;
    dispatchCue?(): void;
};

// @alpha
export type DashManifest = {
    MPD: {
        $?: {
            maxSegmentDuration?: string;
            mediaPresentationDuration?: string;
            minBufferTime?: string;
            profiles?: string;
            type?: string;
            xmlns?: string;
        };
        Period: Period[];
    };
};

// @alpha
export function dashToHam(manifest: string): Presentation[];

// @beta
export const DATA = "data";

// @beta
export type DataEntryUrlBox = FullBox & {
    type: 'url ';
    location?: string;
};

// @beta
export type DataEntryUrnBox = FullBox & {
    type: 'urn ';
    name?: string;
    location?: string;
};

// @beta
export type DataInformationBox = ContainerBox<DataReferenceBox> & {
    type: 'dinf';
};

// @beta
export type DataReferenceBox = FullBox & {
    type: 'dref';
    entryCount: number;
    entries: Array<DataEntryUrlBox | DataEntryUrnBox>;
};

// @beta
export function dataViewToString(dataView: DataView, encoding?: Encoding): string;

// @beta
export function decodeBase64(str: string): Uint8Array;

// @beta
export function decodeCmcd<T extends CmcdData = CmcdData>(cmcd: string): T;

// @beta
export function decodeCmsdDynamic(cmsd: string): CmsdDynamic[];

// @beta
export function decodeCmsdStatic(cmsd: string): CmsdStatic;

// @beta
export type DecodedId3Frame<T> = {
    key: string;
    data: T;
    info?: any;
};

// @beta
export function decodeFairPlayLicense(response: string | ArrayBuffer): Uint8Array;

// @beta
export function decodeIso8601Duration(isoDuration: string): number;

// @beta
export function decodeSfDict(input: string, options?: SfDecodeOptions): SfDictionary;

// @beta
export function decodeSfItem(input: string, options?: SfDecodeOptions): SfItem;

// @beta
export function decodeSfList(input: string, options?: SfDecodeOptions): SfMember[];

// @beta
export type DecodingTimeSample = {
    sampleCount: number;
    sampleDelta: number;
};

// @beta
export type DecodingTimeToSampleBox = FullBox & {
    type: 'stts';
    entryCount: number;
    entries: DecodingTimeSample[];
};

// @beta
export type DegradationPriorityBox = FullBox & {
    type: 'stdp';
    priority: number[];
};

// @beta
export function dref(view: IsoView): Fields<DataReferenceBox>;

// @beta
export type EditBox = ContainerBox<EditListBox> & {
    type: 'edts';
};

// @beta
export type EditListBox = FullBox & {
    type: 'elst';
    entryCount: number;
    entries: EditListEntry[];
};

// @beta
export type EditListEntry = {
    segmentDuration: number;
    mediaTime: number;
    mediaRateInteger: number;
    mediaRateFraction: number;
};

// @beta
export function elng(view: IsoView): Fields<ExtendedLanguageBox>;

// @beta
export function elst(view: IsoView): Fields<EditListBox>;

// @beta
export function emsg(view: IsoView): Fields<EventMessageBox>;

// @beta
export function enca(view: IsoView): Fields<AudioSampleEntryBox<'enca'>>;

// @beta
export function encodeBase64(binary: Uint8Array): string;

// @beta
export function encodeCmcd(cmcd: CmcdData, options?: CmcdEncodeOptions): string;

// @beta
export function encodeCmcdEvent(cmcd: CmcdData, options?: CmcdEncodeOptions): string;

// @beta
export function encodeCmcdRequest(cmcd: CmcdData, options?: CmcdEncodeOptions): string;

// @beta
export function encodeCmcdResponse(cmcd: CmcdData, options?: CmcdEncodeOptions): string;

// @beta
export function encodeCmsdDynamic(value: SfItem[]): string;

// @beta
export function encodeCmsdDynamic(value: string, cmsd: CmsdDynamic): string;

// @beta
export function encodeCmsdStatic(cmsd: CmsdStatic, options?: CmsdEncodeOptions): string;

// @beta
export function encodeIso8601Duration(duration: number): string;

// @beta
export function encodeSfDict(value: Record<string, any> | Map<string, any>, options?: SfEncodeOptions): string;

// @beta
export function encodeSfItem(value: SfItem): string;

// @beta
export function encodeSfItem(value: SfBareItem, params?: SfParameters): string;

// @beta
export function encodeSfList(value: SfMember[], options?: SfEncodeOptions): string;

// @beta
export const Encoding: {
    readonly UTF8: typeof UTF_8;
    readonly UTF16: typeof UTF_16;
};

// @beta
export type Encoding = ValueOf<typeof Encoding>;

// @beta
export type EncryptedSample = {
    initializationVector?: Uint8Array;
    subsampleEncryption?: SubsampleEncryption[];
};

// @beta
export const EncryptionScheme: {
    readonly CENC: typeof CENC;
    readonly CBCS: typeof CBCS;
};

// @beta
export type EncryptionScheme = ValueOf<typeof EncryptionScheme>;

// @beta
export function encv(view: IsoView): Fields<VisualSampleEntryBox<'encv'>>;

// @beta
export type Entity = {
    entityId: number;
};

// @beta
export type EventMessageBox = FullBox & {
    type: 'emsg';
    schemeIdUri: string;
    value: string;
    timescale: number;
    presentationTime: number;
    presentationTimeDelta: number;
    eventDuration: number;
    id: number;
    messageData: Uint8Array;
};

// @beta
export class Ewma {
    constructor(alpha: number);
    getEstimate(): number;
    getTotalDuration(): number;
    sample(weight: number, value: number): void;
}

// @beta
export class EwmaEstimator implements ThroughputEstimator {
    constructor(options: EwmaEstimatorOptions);
    // (undocumented)
    canEstimate(): boolean;
    // (undocumented)
    getEstimate(): number;
    // (undocumented)
    sample(sample: ResourceTiming): void;
}

// @beta
export type EwmaEstimatorOptions = {
    fastHalfLife: number;
    slowHalfLife: number;
};

// @beta
export const EXPIRED = "expired";

// @beta
export type ExtendedLanguageBox = FullBox & {
    type: 'elng';
    extendedLanguage: string;
};

// @beta
export function extractContentId(initData: Uint16Array): string;

// @beta
export function extractCta608Data(raw: DataView, cta608Range: Array<number>): Array<Array<number>>;

// @beta
export const FAIRPLAY_KEY_SYSTEM = "com.apple.fps.1_0";

// @beta
export const FAIRPLAY_UUID = "29701fe4-3cc7-4a34-8c5b-ae90c7439a47";

// @beta
export type Fields<T> = Omit<T, Exclude<keyof Box, 'data'> | 'boxes'>;

// @beta
export type FileTypeBox = TypeBox<'ftyp'>;

// @beta
export function filterBoxes<T extends IsoBmffBox = IsoBmffBox>(raw: IsoData | Iterable<IsoBmffBox>, fn: BoxFilter<T>, config?: IsoViewConfig): T[];

// @beta
export function filterBoxesByType<T extends keyof IsoBmffBoxMap>(raw: IsoData, type: T | T[], config?: IsoViewConfig): IsoBmffBoxMap[T][];

// @beta
export function findBox<T extends IsoBmffBox = IsoBmffBox>(raw: IsoData | Iterable<IsoBmffBox>, fn: BoxFilter<T>, config?: IsoViewConfig): T | null;

// @beta
export function findBoxByType<T extends keyof IsoBmffBoxMap>(raw: IsoData, type: T, config?: IsoViewConfig): IsoBmffBoxMap[T] | null;

// @beta
export function findCencContentProtection(cpArray: ContentProtection[]): ContentProtection | null;

// @beta
export function findCta608Nalus(raw: DataView, startPos: number, size: number): Array<Array<number>>;

// @alpha
export type FrameRate = {
    frameRateNumerator: number;
    frameRateDenominator?: number;
};

// @beta
export function free(view: IsoView): Fields<FreeSpaceBox>;

// @beta
export type FreeSpaceBox<T extends 'free' | 'skip' = 'free'> = Box & {
    type: T;
    data: Uint8Array;
};

// @beta
export function frma(view: IsoView): Fields<OriginalFormatBox>;

// @beta
export function fromCmcdHeaders(headers: Record<string, string> | Headers): Cmcd;

// @beta
export function fromCmcdQuery(query: string | URLSearchParams): Cmcd;

// @beta
export function ftyp(view: IsoView): Fields<FileTypeBox>;

// @beta
export type FullBox = Box & {
    version: number;
    flags: number;
};

// @beta
export function getElementsByName(node: XmlNode, name: string, found?: XmlNode[]): XmlNode[];

// @beta
export function getId(licenseServerUrl: string, initData: Uint16Array, queryParam?: string): string;

// Warning: (ae-internal-missing-underscore) The name "getId3Data" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function getId3Data(data: Uint8Array, offset: number): Uint8Array | undefined;

// @beta
export function getId3Frames(id3Data: Uint8Array): Id3Frame[];

// @beta
export function getId3Timestamp(data: Uint8Array): number | undefined;

// @beta
export function getKeySystemAccess(requests: MediaKeySystemAccessRequest[]): Promise<MediaKeySystemAccess | null>;

// @beta
export function getLegacyKeySystemAccess(requests: MediaKeySystemAccessRequest[]): MediaKeySystemAccessRequest | null;

// @beta
export function getLicenseRequestFromMessage(message: ArrayBuffer, encoding?: Encoding): ArrayBuffer;

// @beta
export function getLicenseServerUrl(initData: Uint16Array): string;

// @beta
export function getLicenseServerUrlFromContentProtection(contentProtectionElements: ContentProtection[], schemeIdUri: string): string | null;

// @beta
export function getPsshData(pssh: ArrayBuffer): ArrayBuffer;

// @beta
export function getPsshForKeySystem(uuid: string, initData: ArrayBuffer): ArrayBuffer | null;

// @beta
export function getRequestHeadersFromMessage(message: ArrayBuffer, encoding?: typeof UTF_8 | typeof UTF_16): Record<string, string>;

// @beta
export function getSupportedKeySystemConfiguration(keySystem: string, configs: Iterable<MediaKeySystemConfiguration>): {
    supportedAudio: MediaKeySystemMediaCapability[];
    supportedVideo: MediaKeySystemMediaCapability[];
};

// @alpha
export function getTracksFromPresentation(presentation: Presentation, predicate?: (track: Track) => boolean): Track[];

// @alpha
export function getTracksFromSelectionSet(selectionSet: SelectionSet, predicate?: (track: Track) => boolean): Track[];

// @alpha
export function getTracksFromSwitchingSet(switchingSet: SwitchingSet, predicate?: (track: Track) => boolean): Track[];

// @alpha
export type Ham = {
    id: string;
};

// @alpha
export function hamToDash(presentation: Presentation[]): Manifest;

// @alpha
export function hamToHls(presentation: Presentation[]): Manifest;

// @beta
export type HandlerReferenceBox = FullBox & {
    type: 'hdlr';
    preDefined: number;
    handlerType: string;
    reserved: number[];
    name: string;
};

// @beta
export class HarmonicMeanEstimator implements ThroughputEstimator {
    // (undocumented)
    getEstimate(): number;
    // (undocumented)
    sample(sample: ResourceTiming): void;
}

// @beta
export function hdlr(view: IsoView): Fields<HandlerReferenceBox>;

// @beta
export function hev1(view: IsoView): Fields<VisualSampleEntryBox<'hev1'>>;

// @beta
export type HintMediaHeaderBox = FullBox & {
    type: 'hmhd';
    maxPDUsize: number;
    avgPDUsize: number;
    maxbitrate: number;
    avgbitrate: number;
};

// @alpha
export type HlsManifest = {
    playlists: PlayList[];
    mediaGroups: MediaGroups;
    segments: SegmentHls[];
    targetDuration?: number;
};

// @alpha
export function hlsToHam(manifest: string, ancillaryManifests: string[]): Presentation[];

// @beta
export const HTTP_HEADERS = "HttpHeaders";

// @beta
export function hvc1(view: IsoView): Fields<VisualSampleEntryBox<'avc1'>>;

// @beta
export const HW_SECURE_ALL = "HW_SECURE_ALL";

// @beta
export const HW_SECURE_CRYPTO = "HW_SECURE_CRYPTO";

// @beta
export const HW_SECURE_DECODE = "HW_SECURE_DECODE";

// @beta
export const ID3_SCHEME_ID_URI = "https://aomedia.org/emsg/ID3";

// @beta
export type Id3Frame = DecodedId3Frame<ArrayBuffer | string | number>;

// @beta
export function iden(view: IsoView): Fields<WebVttCueIdBox>;

// @beta
export type IdentifiedMediaDataBox = Box & {
    type: 'imda';
    imdaIdentifier: number;
    data: Uint8Array;
};

// @beta
export function imda(view: IsoView): Fields<IdentifiedMediaDataBox>;

// @beta
export const INDIVIDUALIZATION_REQUEST = "individualization-request";

// @alpha
export type Initialization = {
    $: {
        range?: string;
        sourceURL?: string;
    };
};

// @beta
export const InitializationDataType: {
    readonly CENC: typeof CENC;
    readonly CBCS: typeof CBCS;
    readonly KEYIDS: typeof KEYIDS;
    readonly WEBM: typeof WEBM;
};

// @beta
export type InitializationDataType = ValueOf<typeof InitializationDataType>;

// @beta
export const INT = "int";

// @beta
export const INTERNAL_ERROR = "internal-error";

// @beta
export type IpmpInfoBox = FullBox & {
    type: 'imif';
    ipmpDescr: any[];
};

// @beta
export function isCmcdCustomKey(key: CmcdKey): boolean;

// @beta
export function isCmcdEventKey(key: string): boolean;

// @beta
export function isCmcdRequestKey(key: string): boolean;

// @beta
export function isCmcdResponeKey(key: string): boolean;

// @beta
export function isCmcdV1Key(key: string): boolean;

// Warning: (ae-internal-missing-underscore) The name "isId3TimestampFrame" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isId3TimestampFrame(frame: Id3Frame): boolean;

// @beta
export type IsoBmffBox = IsoBox | IsoContainerBox;

// @beta
export type IsoBmffBoxMap = {
    ardi: AudioRenderingIndicationBox;
    avc1: VisualSampleEntryBox<'avc1'>;
    avc2: VisualSampleEntryBox<'avc2'>;
    avc3: VisualSampleEntryBox<'avc3'>;
    avc4: VisualSampleEntryBox<'avc4'>;
    co64: ChunkLargeOffsetBox;
    ctts: CompositionTimeToSampleBox;
    dinf: DataInformationBox;
    dref: DataReferenceBox;
    edts: EditBox;
    elng: ExtendedLanguageBox;
    elst: EditListBox;
    emsg: EventMessageBox;
    enca: AudioSampleEntryBox<'enca'>;
    encv: VisualSampleEntryBox<'encv'>;
    free: FreeSpaceBox<'free'>;
    frma: OriginalFormatBox;
    ftyp: FileTypeBox;
    hdlr: HandlerReferenceBox;
    hev1: VisualSampleEntryBox<'hev1'>;
    hmhd: HintMediaHeaderBox;
    hvc1: VisualSampleEntryBox<'hvc1'>;
    iden: WebVttCueIdBox;
    iinf: ItemInfoBox;
    iloc: ItemLocationBox;
    imda: IdentifiedMediaDataBox;
    imif: IpmpInfoBox;
    infe: ItemInfoEntry;
    ipro: ItemProtectionBox;
    iref: ItemReferenceBox;
    kind: TrackKindBox;
    labl: LabelBox;
    mdat: MediaDataBox;
    mdhd: MediaHeaderBox;
    mdia: MediaBox;
    mehd: MovieExtendsHeaderBox;
    meta: MetaBox;
    mfhd: MovieFragmentHeaderBox;
    mfra: MovieFragmentRandomAccessBox;
    mfro: MovieFragmentRandomAccessOffsetBox;
    minf: MediaInformationBox;
    moof: MovieFragmentBox;
    moov: MovieBox;
    mp4a: AudioSampleEntryBox<'mp4a'>;
    mvex: MovieExtendsBox;
    mvhd: MovieHeaderBox;
    nmhd: NullMediaHeaderBox;
    payl: WebVttCuePayloadBox;
    pitm: PrimaryItemBox;
    prft: ProducerReferenceTimeBox;
    prsl: PreselectionGroupBox;
    pssh: ProtectionSystemSpecificHeaderBox;
    saio: SampleAuxiliaryInformationOffsetsBox;
    saiz: SampleAuxiliaryInformationSizesBox;
    sbgp: SampleToGroupBox;
    schi: SchemeInformationBox;
    schm: SchemeTypeBox;
    sdtp: SampleDependencyTypeBox;
    senc: SampleEncryptionBox;
    sgpd: SampleGroupDescriptionBox;
    sidx: SegmentIndexBox;
    sinf: ProtectionSchemeInformationBox;
    skip: FreeSpaceBox<'skip'>;
    smhd: SoundMediaHeaderBox;
    ssix: SubsegmentIndexBox;
    stbl: SampleTableBox;
    stco: ChunkOffsetBox;
    stdp: DegradationPriorityBox;
    sthd: SubtitleMediaHeaderBox;
    stsc: SampleToChunkBox;
    stsd: SampleDescriptionBox;
    stsh: ShadowSyncSampleBox;
    stss: SyncSampleBox;
    stsz: SampleSizeBox;
    sttg: WebVttSettingsBox;
    stts: DecodingTimeToSampleBox;
    styp: SegmentTypeBox;
    subs: SubsampleInformationBox;
    stz2: CompactSampleSizeBox;
    tenc: TrackEncryptionBox;
    tfdt: TrackFragmentBaseMediaDecodeTimeBox;
    tfhd: TrackFragmentHeaderBox;
    tfra: TrackFragmentRandomAccessBox;
    tkhd: TrackHeaderBox;
    traf: TrackFragmentBox;
    trak: TrackBox;
    tref: TrackReferenceBox;
    trex: TrackExtendsBox;
    trun: TrackRunBox;
    udta: UserDataBox;
    url: DataEntryUrlBox;
    urn: DataEntryUrnBox;
    vlab: WebVttSourceLabelBox;
    vmhd: VideoMediaHeaderBox;
    vttC: WebVttConfigurationBox;
    vtte: WebVttEmptySampleBox;
};

// @beta
export type IsoBox = AudioRenderingIndicationBox | AudioSampleEntryBox<'enca'> | AudioSampleEntryBox<'mp4a'> | ChunkLargeOffsetBox | ChunkOffsetBox | CompactSampleSizeBox | CompositionTimeToSampleBox | DataEntryUrlBox | DataEntryUrnBox | DataReferenceBox | DecodingTimeToSampleBox | DegradationPriorityBox | EditListBox | EventMessageBox | ExtendedLanguageBox | FileTypeBox | FreeSpaceBox<'free'> | FreeSpaceBox<'skip'> | HandlerReferenceBox | HintMediaHeaderBox | IdentifiedMediaDataBox | IpmpInfoBox | ItemInfoEntry | ItemLocationBox | LabelBox | MediaDataBox | MediaHeaderBox | MovieExtendsHeaderBox | MovieFragmentHeaderBox | MovieFragmentRandomAccessOffsetBox | MovieHeaderBox | NullMediaHeaderBox | OriginalFormatBox | PrimaryItemBox | PreselectionGroupBox | ProducerReferenceTimeBox | ProtectionSystemSpecificHeaderBox | SampleAuxiliaryInformationOffsetsBox | SampleAuxiliaryInformationSizesBox | SampleDependencyTypeBox | SampleDescriptionBox | SampleEncryptionBox | SampleGroupDescriptionBox | SampleSizeBox | SampleToChunkBox | SampleToGroupBox | SchemeTypeBox | SegmentIndexBox | SegmentTypeBox | ShadowSyncSampleBox | SingleItemTypeReferenceBox | SoundMediaHeaderBox | SubsampleInformationBox | SubsegmentIndexBox | SubtitleMediaHeaderBox | SyncSampleBox | TrackEncryptionBox | TrackExtendsBox | TrackFragmentBaseMediaDecodeTimeBox | TrackFragmentHeaderBox | TrackFragmentRandomAccessBox | TrackHeaderBox | TrackKindBox | TrackRunBox | UrlBox | UrnBox | VideoMediaHeaderBox | VisualSampleEntryBox<'avc1'> | VisualSampleEntryBox<'avc2'> | VisualSampleEntryBox<'avc3'> | VisualSampleEntryBox<'avc4'> | VisualSampleEntryBox<'encv'> | VisualSampleEntryBox<'hev1'> | VisualSampleEntryBox<'hvc1'> | WebVttConfigurationBox | WebVttCueIdBox | WebVttCuePayloadBox | WebVttEmptySampleBox | WebVttSettingsBox | WebVttSourceLabelBox;

// @beta
export type IsoContainerBox = DataInformationBox | EditBox | ItemInfoBox | ItemProtectionBox | ItemReferenceBox | MediaBox | MediaInformationBox | MetaBox | MovieBox | MovieExtendsBox | MovieFragmentBox | MovieFragmentRandomAccessBox | ProtectionSchemeInformationBox | SampleTableBox | SchemeInformationBox | TrackBox | TrackFragmentBox | TrackReferenceBox | UserDataBox;

// @beta
export type IsoData = ArrayBuffer | DataView | Uint8Array;

// @beta
export type IsoFieldTypeMap = {
    uint: number;
    int: number;
    template: number;
    string: string;
    data: Uint8Array;
    utf8: string;
    utf8string: string;
};

// @beta
export class IsoView {
    [Symbol.iterator](): Generator<IsoBmffBox>;
    constructor(raw: ArrayBuffer | DataView | Uint8Array, config?: IsoViewConfig);
    get bytesRemaining(): number;
    get cursor(): number;
    get done(): boolean;
    readArray: <T extends keyof IsoFieldTypeMap>(type: T, size: number, length: number) => IsoFieldTypeMap[T][];
    readBox: () => RawBox;
    readBoxes: <T = IsoBmffBox>(length: number) => T[];
    readData: (size: number) => Uint8Array;
    readEntries: <T>(length: number, map: () => T) => T[];
    readFullBox: () => Fields<FullBox>;
    readInt: (size: number) => number;
    readString: (size: number) => string;
    readTemplate: (size: number) => number;
    readUint: (size: number) => number;
    readUtf8: (size?: number) => string;
    slice: (size: number) => IsoView;
}

// @beta
export type IsoViewConfig = {
    parsers?: BoxParserMap;
    recursive?: boolean;
};

// @beta
export type ItemExtent = {
    extentIndex?: number;
    extentOffset: number;
    extentLength: number;
};

// @beta
export type ItemInfoBox = ContainerBox<ItemInfoEntry> & {
    type: 'iinf';
    entryCount: number;
};

// @beta
export type ItemInfoEntry = FullBox & {
    type: 'infe';
    itemId: number;
    itemProtectionIndex: number;
    itemName: string;
    contentType: string;
    contentEncoding?: string;
    extensionType?: string;
};

// @beta
export type ItemLocation = {
    itemId: number;
    constructionMethod?: number;
    dataReferenceIndex: number;
    baseOffset: number;
    extents: ItemExtent[];
};

// @beta
export type ItemLocationBox = FullBox & {
    type: 'iloc';
    offsetSize: number;
    lengthSize: number;
    baseOffsetSize: number;
    indexSize?: number;
    itemCount: number;
    items: ItemLocation[];
};

// @beta
export type ItemProtectionBox = ContainerBox<ProtectionSchemeInformationBox> & {
    type: 'ipro';
    protectionCount: number;
};

// @beta
export type ItemReferenceBox = ContainerBox<SingleItemTypeReferenceBox> & {
    type: 'iref';
};

// @beta
export const KEYIDS = "keyids";

// @beta
export function kind(view: IsoView): Fields<TrackKindBox>;

// @beta
export type LabelBox = FullBox & {
    type: 'labl';
    isGroupLabel: boolean;
    labelId: number;
    language: string;
    label: string;
};

// @beta
export function labl(view: IsoView): Fields<LabelBox>;

// @beta
export const LICENSE_ACQUISITION = "LicenseAcquisition";

// @beta
export const LICENSE_RELEASE = "license-release";

// @beta
export const LICENSE_RENEWAL = "license-renewal";

// @beta
export const LICENSE_REQUEST = "license-request";

// @beta
export type LicenseRequest = {
    url: string;
    method: 'GET' | 'POST';
    responseType: XMLHttpRequestResponseType;
    headers?: Record<string, string>;
    withCredentials?: boolean;
    messageType?: MediaKeyMessageType;
    sessionId?: string;
    data?: ArrayBuffer;
};

// @alpha
export type Manifest = {
    manifest: string;
    fileName?: string;
    ancillaryManifests?: Manifest[];
    type: ManifestFormat;
    metadata?: Map<string, string>;
};

// @alpha
export type ManifestFormat = 'hls' | 'dash';

// @beta
export function mdat(view: IsoView): Fields<MediaDataBox>;

// @beta
export function mdhd(view: IsoView): Fields<MediaHeaderBox>;

// @beta
export type MediaBox = ContainerBox<MediaHeaderBox | HandlerReferenceBox | MediaInformationBox> & {
    type: 'mdia';
};

// @beta
export type MediaDataBox = Box & {
    type: 'mdat';
    data: Uint8Array;
};

// @alpha
export type MediaGroups = {
    AUDIO: {
        [key: string]: {
            [key: string]: {
                language: string;
            };
        };
    };
    SUBTITLES: {
        [key: string]: {
            [key: string]: {
                language: string;
            };
        };
    };
};

// @beta
export type MediaHeaderBox = FullBox & {
    type: 'mdhd';
    creationTime: number;
    modificationTime: number;
    timescale: number;
    duration: number;
    language: string;
    preDefined: number;
};

// @beta
export type MediaInformationBox = ContainerBox<VideoMediaHeaderBox | SoundMediaHeaderBox | HintMediaHeaderBox | NullMediaHeaderBox | DataInformationBox | SampleTableBox> & {
    type: 'minf';
};

// @beta
const MediaKeyMessageType_2: {
    readonly LICENSE_REQUEST: typeof LICENSE_REQUEST;
    readonly LICENSE_RENEWAL: typeof LICENSE_RENEWAL;
    readonly LICENSE_RELEASE: typeof LICENSE_RELEASE;
    readonly INDIVIDUALIZATION_REQUEST: typeof INDIVIDUALIZATION_REQUEST;
};

// @beta
type MediaKeyMessageType_2 = ValueOf<typeof MediaKeyMessageType_2>;
export { MediaKeyMessageType_2 as MediaKeyMessageType }

// @beta
const MediaKeyStatus_2: {
    readonly USABLE: typeof USABLE;
    readonly EXPIRED: typeof EXPIRED;
    readonly RELEASED: typeof RELEASED;
    readonly OUTPUT_RESTRICTED: typeof OUTPUT_RESTRICTED;
    readonly OUTPUT_DOWNSCALED: typeof OUTPUT_DOWNSCALED;
    readonly STATUS_PENDING: typeof STATUS_PENDING;
    readonly INTERNAL_ERROR: typeof INTERNAL_ERROR;
};

// @beta
type MediaKeyStatus_2 = ValueOf<typeof MediaKeyStatus_2>;
export { MediaKeyStatus_2 as MediaKeyStatus }

// @public
export type MediaKeySystemAccessRequest = {
    keySystem: string;
    configurations: MediaKeySystemConfiguration[];
};

// @beta
export function mehd(view: IsoView): Fields<MovieExtendsHeaderBox>;

// @beta
export function meta(view: IsoView): Fields<MetaBox>;

// @beta
export type MetaBox = FullBox & ContainerBox<HandlerReferenceBox | PrimaryItemBox | DataInformationBox | ItemLocationBox | ItemProtectionBox | ItemInfoBox | ItemReferenceBox> & {
    type: 'meta';
};

// @beta
export function mfhd(view: IsoView): Fields<MovieFragmentHeaderBox>;

// @beta
export function mfro(view: IsoView): Fields<MovieFragmentRandomAccessOffsetBox>;

// @beta
export type MovieBox = ContainerBox<MovieHeaderBox | TrackBox | MovieExtendsBox | UserDataBox> & {
    type: 'moov';
};

// @beta
export type MovieExtendsBox = ContainerBox<MovieExtendsHeaderBox | TrackExtendsBox> & {
    type: 'mvex';
};

// @beta
export type MovieExtendsHeaderBox = FullBox & {
    type: 'mehd';
    fragmentDuration: number;
};

// @beta
export type MovieFragmentBox = ContainerBox<MovieFragmentHeaderBox | TrackFragmentBox> & {
    type: 'moof';
};

// @beta
export type MovieFragmentHeaderBox = FullBox & {
    type: 'mfhd';
    sequenceNumber: number;
};

// @beta
export type MovieFragmentRandomAccessBox = ContainerBox<TrackFragmentRandomAccessBox | MovieFragmentRandomAccessOffsetBox> & {
    type: 'mfra';
};

// @beta
export type MovieFragmentRandomAccessOffsetBox = FullBox & {
    type: 'mfro';
    mfraSize: number;
};

// @beta
export type MovieHeaderBox = FullBox & {
    type: 'mvhd';
    creationTime: number;
    modificationTime: number;
    timescale: number;
    duration: number;
    rate: number;
    volume: number;
    reserved1: number;
    reserved2: number[];
    matrix: number[];
    preDefined: number[];
    nextTrackId: number;
};

// @beta
export const MP4_PROTECTION_SCHEME = "urn:mpeg:dash:mp4protection:2011";

// @beta
export function mp4a(view: IsoView): Fields<AudioSampleEntryBox<'mp4a'>>;

// @beta
export function mvhd(view: IsoView): Fields<MovieHeaderBox>;

// @beta
export type NullMediaHeaderBox = FullBox & {
    type: 'nmhd';
};

// @beta
export type OriginalFormatBox = Box & {
    type: 'frma';
    dataFormat: number;
};

// @beta
export const OUTPUT_DOWNSCALED = "output-downscaled";

// @beta
export const OUTPUT_RESTRICTED = "output-restricted";

// @beta
export type PACData = {
    row: number;
    indent: number | null;
    color: string | null;
    underline: boolean;
    italics: boolean;
};

// @beta
export function parseBoxes(raw: IsoData, config?: IsoViewConfig): IsoBmffBox[];

// @beta
export function parseInitDataFromContentProtection(cpData: ContentProtection, BASE64: {
    decodeArray: (input: string) => Uint8Array;
}): ArrayBuffer | null;

// @beta
export function parsePsshList(data: ArrayBuffer): Record<string, ArrayBuffer>;

// @beta
export function parseWebVtt(text: string, options?: WebVttParserOptions): WebVttParseResult;

// @beta
export function parseXml(input: string, options?: XmlParseOptions): XmlNode;

// @beta
export function payl(view: IsoView): Fields<WebVttCuePayloadBox>;

// @beta
export class PenState {
    // (undocumented)
    background: string;
    // (undocumented)
    copy(newPenState: PenState): void;
    // (undocumented)
    equals(other: PenState): boolean;
    // (undocumented)
    flash: boolean;
    // (undocumented)
    foreground: string;
    // (undocumented)
    isDefault(): boolean;
    // (undocumented)
    italics: boolean;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setStyles(styles: Partial<PenStyles>): void;
    // (undocumented)
    underline: boolean;
}

// @beta
export type PenStyles = {
    foreground: string | null;
    underline: boolean;
    italics: boolean;
    background: string;
    flash: boolean;
};

// @alpha
export type Period = {
    $: {
        duration: string;
        id?: string;
        start?: string;
    };
    AdaptationSet: AdaptationSet[];
};

// @alpha
export type PlayList = {
    uri: string;
    attributes: {
        FRAME_RATE: number;
        CODECS: string;
        BANDWIDTH: number;
        RESOLUTION: {
            width: number;
            height: number;
        };
    };
};

// @beta
export const PLAYREADY_KEY_MESSAGE = "PlayReadyKeyMessage";

// @beta
export const PLAYREADY_KEY_SYSTEM = "com.microsoft.playready";

// @beta
export const PLAYREADY_RECOMMENDATION_KEY_SYSTEM = "com.microsoft.playready.recommendation";

// @beta
export const PLAYREADY_UUID = "9a04f079-9840-4286-ab92-e65be0885f95";

// @beta
export type PreselectionGroupBox = FullBox & {
    type: 'prsl';
    groupId: number;
    numEntitiesInGroup: number;
    entities: Entity[];
    preselectionTag?: string;
    selectionPriority?: number;
    interleavingTag?: string;
};

// @alpha
export type Presentation = Ham & {
    selectionSets: SelectionSet[];
};

// @beta
export function prft(view: IsoView): Fields<ProducerReferenceTimeBox>;

// @beta
export type PrimaryItemBox = FullBox & {
    type: 'pitm';
    itemId: number;
};

// @beta
export function processUriTemplate(uriTemplate: string, representationId: string | null | undefined, number: number | null | undefined, subNumber: number | null | undefined, bandwidth: number | null | undefined, time: string | number | null | undefined): string;

// @beta
export type ProducerReferenceTimeBox = FullBox & {
    type: 'prft';
    referenceTrackId: number;
    ntpTimestampSec: number;
    ntpTimestampFrac: number;
    mediaTime: number;
};

// @beta
export type ProtectionSchemeInformationBox = ContainerBox<OriginalFormatBox | IpmpInfoBox | SchemeTypeBox | SchemeInformationBox> & {
    type: 'sinf';
};

// @beta
export type ProtectionSystemSpecificHeaderBox = FullBox & {
    type: 'pssh';
    systemId: number[];
    dataSize: number;
    data: number[];
};

// @beta
export function prsl(view: IsoView): Fields<PreselectionGroupBox>;

// @beta
export function pssh(view: IsoView): Fields<ProtectionSystemSpecificHeaderBox>;

// @beta
export type RawBox = {
    type: string;
    size: number;
    largesize?: number;
    usertype?: number[];
    data: IsoView;
};

// @beta
export const RELEASED = "released";

// @alpha
export type Representation = {
    $: {
        audioSamplingRate?: string;
        bandwidth: string;
        codecs?: string;
        frameRate?: string;
        height?: string;
        id: string;
        mimeType?: string;
        sar?: string;
        scanType?: string;
        startWithSAP?: string;
        width?: string;
    };
    AudioChannelConfiguration?: AudioChannelConfiguration[];
    BaseURL?: string[];
    SegmentBase?: SegmentBase[];
    SegmentList?: SegmentList[];
    SegmentTemplate?: SegmentTemplate[];
};

// @beta
export type Requester = (request: CommonMediaRequest) => Promise<CommonMediaResponse>;

// @beta
export type RequestInterceptor = (request: CommonMediaRequest) => Promise<CommonMediaRequest>;

// @beta
export const RequestType: {
    readonly TEXT: "text";
    readonly JSON: "json";
    readonly BLOB: "blob";
    readonly ARRAY_BUFFER: "arrayBuffer";
    readonly DOCUMENT: "document";
};

// @beta (undocumented)
export type RequestType = ValueOf<typeof RequestType>;

// @beta
export type ResourceTiming = {
    startTime: number;
    encodedBodySize: number;
    responseStart?: number;
    duration: number;
};

// @beta
export type ResponseInterceptor = (response: CommonMediaResponse) => Promise<CommonMediaResponse>;

// @beta
export type ResponseTypeMap<T extends string | undefined> = T extends 'json' ? any : T extends 'text' ? string : T extends 'blob' ? Blob : T extends 'arraybuffer' ? ArrayBuffer : T extends 'document' ? XmlNode : unknown;

// @alpha
export type Role = {
    $: {
        schemeIdUri: string;
        value: string;
    };
};

// @beta
export function roundToEven(value: number, precision: number): number;

// @beta
export class Row {
    constructor(logger?: CaptionsLogger);
    backSpace(): void;
    // (undocumented)
    chars: StyledUnicodeChar[];
    // (undocumented)
    clear(): void;
    // (undocumented)
    clearFromPos(startPos: number): void;
    // (undocumented)
    clearToEndOfRow(): void;
    // (undocumented)
    copy(other: Row): void;
    // (undocumented)
    cueStartTime: number | null;
    // (undocumented)
    equals(other: Row): boolean;
    // (undocumented)
    getTextString(): string;
    // (undocumented)
    insertChar(byte: number): void;
    // (undocumented)
    isEmpty(): boolean;
    moveCursor(relPos: number): void;
    setCursor(absPos: number): void;
    // (undocumented)
    setPenStyles(styles: Partial<PenStyles>): void;
}

// @beta
export type SampleAuxiliaryInformationOffsetsBox = FullBox & {
    type: 'saio';
    auxInfoType?: number;
    auxInfoTypeParameter?: number;
    entryCount: number;
    offset: number[];
};

// @beta
export type SampleAuxiliaryInformationSizesBox = FullBox & {
    type: 'saiz';
    auxInfoType?: number;
    auxInfoTypeParameter?: number;
    defaultSampleInfoSize: number;
    sampleCount: number;
    sampleInfoSize?: number[];
};

// @beta
export type SampleDependencyTypeBox = FullBox & {
    type: 'sdtp';
    sampleDependencyTable: number[];
};

// @beta
export type SampleDescriptionBox<E extends SampleEntryBox = SampleEntryBox> = FullBox & {
    type: 'stsd';
    entryCount: number;
    entries: E[];
};

// @beta
export type SampleEncryptionBox = FullBox & {
    type: 'senc';
    sampleCount: number;
    samples: EncryptedSample[];
};

// @beta
export type SampleEntryBox = Box & {
    reserved1: number[];
    dataReferenceIndex: number;
};

// @beta
export type SampleGroupDescriptionBox = FullBox & {
    type: 'sgpd';
    groupingType: number;
    defaultLength?: number;
    entryCount: number;
    entries: any[];
};

// @beta
export type SampleSizeBox = FullBox & {
    type: 'stsz';
    sampleSize: number;
    sampleCount: number;
    entrySize?: number[];
};

// @beta
export type SampleTableBox = ContainerBox<SampleDescriptionBox | DecodingTimeToSampleBox | CompositionTimeToSampleBox | SampleToChunkBox | SampleSizeBox | ChunkOffsetBox | SyncSampleBox | ShadowSyncSampleBox | DegradationPriorityBox | SampleDependencyTypeBox | SampleToGroupBox | SampleGroupDescriptionBox> & {
    type: 'stbl';
};

// @beta
export type SampleToChunkBox = FullBox & {
    type: 'stsc';
    entryCount: number;
    entries: SampleToChunkEntry[];
};

// @beta
export type SampleToChunkEntry = {
    firstChunk: number;
    samplesPerChunk: number;
    sampleDescriptionIndex: number;
};

// @beta
export type SampleToGroupBox = FullBox & {
    type: 'sbgp';
    groupingType: number;
    groupingTypeParameter?: number;
    entryCount: number;
    entries: SampleToGroupEntry[];
};

// @beta
export type SampleToGroupEntry = {
    sampleCount: number;
    groupDescriptionIndex: number;
};

// @beta
export class SccParser {
    constructor(processor: any, field?: number | any);
    // (undocumented)
    field: number | any;
    // (undocumented)
    getField(): number | any;
    // (undocumented)
    getHeaderStatus(): boolean;
    // (undocumented)
    getLinesParsed(): number;
    // (undocumented)
    hasHeader: boolean;
    // (undocumented)
    nrLinesParsed: number;
    // (undocumented)
    parse(text: string): void;
    // (undocumented)
    parseDataLine(line: string): [number, number[]] | null;
    // (undocumented)
    processor: any;
    // (undocumented)
    timeConverter(smpteTs: string): number;
}

// @beta
export type SchemeInformationBox = ContainerBox<TrackEncryptionBox | Box> & {
    type: 'schi';
};

// @beta
export type SchemeTypeBox = FullBox & {
    type: 'schm';
    schemeType: number;
    schemeVersion: number;
    schemeUri?: string;
};

// @beta
export function schm(view: IsoView): Fields<SchemeTypeBox>;

// @beta
export function sdtp(view: IsoView): Fields<SampleDependencyTypeBox>;

// @alpha
export type Segment = {
    duration: number;
    url: string;
    byteRange?: string;
};

// @alpha
export type SegmentBase = {
    $: {
        indexRange: string;
        indexRangeExact: string;
        timescale: string;
    };
    Initialization: Initialization[];
};

// @alpha
export type SegmentHls = {
    title?: string;
    duration: number;
    byterange?: Byterange;
    uri?: string;
    timeline?: number;
    map?: {
        uri: string;
        byterange: Byterange;
    };
};

// @beta
export type SegmentIndexBox = FullBox & {
    type: 'sidx';
    referenceId: number;
    timescale: number;
    earliestPresentationTime: number;
    firstOffset: number;
    reserved: number;
    references: SegmentIndexReference[];
};

// @beta
export type SegmentIndexReference = {
    reference: number;
    subsegmentDuration: number;
    sap: number;
    referenceType: number;
    referencedSize: number;
    startsWithSap: number;
    sapType: number;
    sapDeltaTime: number;
};

// @alpha
export type SegmentList = {
    $: {
        duration: string;
        timescale: string;
    };
    Initialization: Initialization[];
    SegmentURL?: SegmentURL[];
};

// @alpha
export type SegmentTemplate = {
    $: {
        duration: string;
        initialization: string;
        media: string;
        startNumber: string;
        timescale: string;
    };
};

// @beta
export type SegmentTypeBox = TypeBox<'styp'>;

// @alpha
export type SegmentURL = {
    $: {
        media?: string;
    };
};

// @alpha
export type SelectionSet = Ham & {
    switchingSets: SwitchingSet[];
    alignedSwitchingSets?: AlignedSwitchingSet[];
};

// Warning: (ae-forgotten-export) The symbol "DashParser" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "setDashParser" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function setDashParser(parser: DashParser): void;

// Warning: (ae-forgotten-export) The symbol "DashSerializer" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "setDashSerializer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function setDashSerializer(serializer: DashSerializer): void;

// Warning: (ae-forgotten-export) The symbol "HlsParser" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "setHlsParser" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function setHlsParser(parser: HlsParser): void;

// @beta
export type SfBareItem = string | Uint8Array | boolean | number | symbol | Date | SfToken;

// @beta
export type SfDecodeOptions = {
    useSymbol?: boolean;
};

// @beta
export type SfDictionary = Record<string, SfMember> | Map<string, SfMember>;

// @beta
export type SfEncodeOptions = {
    whitespace?: boolean;
};

// @beta
export type SfInnerList = {
    value: SfItem[] | SfBareItem[];
    params: SfParameters;
};

// @beta
export class SfItem {
    constructor(value: any, params?: SfParameters);
    // (undocumented)
    params?: SfParameters;
    // (undocumented)
    value: SfBareItem;
}

// @beta
export type SfMember = SfItem | SfInnerList | SfBareItem;

// @beta
export type SfParameters = Record<string, any>;

// @beta
export class SfToken {
    constructor(description: string);
    // (undocumented)
    description: string;
}

// @beta
export type ShadowSyncEntry = {
    shadowedSampleNumber: number;
    syncSampleNumber: number;
};

// @beta
export type ShadowSyncSampleBox = FullBox & {
    type: 'stsh';
    entryCount: number;
    entries: ShadowSyncEntry[];
};

// @beta
export function sidx(view: IsoView): Fields<SegmentIndexBox>;

// @beta
export type SingleItemTypeReferenceBox = Box & {
    fromItemId: number;
    referenceCount: number;
    toItemId: number[];
};

// @beta
export function skip(view: IsoView): Fields<FreeSpaceBox<'skip'>>;

// @beta
export function smhd(view: IsoView): Fields<SoundMediaHeaderBox>;

// @beta
export type SoundMediaHeaderBox = FullBox & {
    type: 'smhd';
    balance: number;
    reserved: number;
};

// @beta
export function ssix(view: IsoView): Fields<SubsegmentIndexBox>;

// @beta
export const STATUS_PENDING = "status-pending";

// @beta
export function sthd(view: IsoView): Fields<SubtitleMediaHeaderBox>;

// @beta
export const STRING = "string";

// @beta
export function stringToUint16(str: string): Uint16Array;

// @beta
export function stsd<E extends SampleEntryBox = SampleEntryBox>(view: IsoView): Fields<SampleDescriptionBox<E>>;

// @beta
export function stss(view: IsoView): Fields<SyncSampleBox>;

// @beta
export function sttg(view: IsoView): Fields<WebVttSettingsBox>;

// @beta
export function stts(view: IsoView): Fields<DecodingTimeToSampleBox>;

// @beta
export class StyledUnicodeChar {
    // (undocumented)
    copy(newChar: StyledUnicodeChar): void;
    // (undocumented)
    equals(other: StyledUnicodeChar): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    penState: PenState;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setChar(uchar: string, newPenState: PenState): void;
    // (undocumented)
    setPenState(newPenState: PenState): void;
    // (undocumented)
    uchar: string;
}

// @beta
export function styp(view: IsoView): Fields<SegmentTypeBox>;

// @beta
export function subs(view: IsoView): Fields<SubsampleInformationBox>;

// @beta
export type Subsample = {
    subsampleSize: number;
    subsamplePriority: number;
    discardable: number;
    codecSpecificParameters: number;
};

// @beta
export type SubsampleEncryption = {
    bytesOfClearData: number;
    bytesOfProtectedData: number;
};

// @beta
export type SubsampleEntry = {
    sampleDelta: number;
    subsampleCount: number;
    subsamples: Subsample[];
};

// @beta
export type SubsampleInformationBox = FullBox & {
    type: 'subs';
    entryCount: number;
    entries: SubsampleEntry[];
};

// @beta
export type Subsegment = {
    rangesCount: number;
    ranges: SubsegmentRange[];
};

// @beta
export type SubsegmentIndexBox = FullBox & {
    type: 'ssix';
    subsegmentCount: number;
    subsegments: Subsegment[];
};

// @beta
export type SubsegmentRange = {
    level: number;
    rangeSize: number;
};

// @beta
export type SubtitleMediaHeaderBox = FullBox & {
    type: 'sthd';
};

// @beta
export type SupportedField = 1 | 3;

// @beta
export const SW_SECURE_CRYPTO = "SW_SECURE_CRYPTO";

// @beta
export const SW_SECURE_DECODE = "SW_SECURE_DECODE";

// @alpha
export type SwitchingSet = Ham & {
    tracks: Track[];
};

// @beta
export type SyncSample = {
    sampleNumber: number;
};

// @beta
export type SyncSampleBox = FullBox & {
    type: 'stss';
    entryCount: number;
    entries: SyncSample[];
};

// @beta
export const TEMPLATE = "template";

// @beta
export function tenc(view: IsoView): Fields<TrackEncryptionBox>;

// @beta
export const TEXT_XML_UTF8 = "text/xml; charset=utf-8";

// @alpha
type TextTrack_2 = Track;
export { TextTrack_2 as TextTrack }

// @beta
export function tfdt(view: IsoView): Fields<TrackFragmentBaseMediaDecodeTimeBox>;

// @beta
export function tfhd(view: IsoView): Fields<TrackFragmentHeaderBox>;

// @beta
export function tfra(view: IsoView): Fields<TrackFragmentRandomAccessBox>;

// @beta
export type ThroughputEstimator = {
    sample(sample: ResourceTiming): void;
    getEstimate(): number;
};

// @beta
export type TimestampMap = {
    MPEGTS: number;
    LOCAL: number;
};

// @beta
export function tkhd(view: IsoView): Fields<TrackHeaderBox>;

// @beta
export function toCmcdHeaders(cmcd: CmcdData, options?: CmcdEncodeOptions): Record<CmcdHeaderField, string>;

// @beta
export function toCmcdJson(cmcd: Cmcd, options?: CmcdEncodeOptions): string;

// @beta
export function toCmcdQuery(cmcd: Cmcd, options?: CmcdEncodeOptions): string;

// @beta
export function toVttCue(cue: WebVttCue): VTTCue;

// @beta
export function toVttRegion(region: WebVttRegion): VTTRegion;

// @alpha
export type Track = Ham & {
    type: TrackType;
    fileName?: string;
    codec: string;
    duration: number;
    language: string;
    bandwidth: number;
    byteRange?: string;
    urlInitialization?: string;
    segments: Segment[];
};

// @beta
export type TrackBox = ContainerBox<TrackHeaderBox | TrackReferenceBox | EditBox | MediaBox | UserDataBox> & {
    type: 'trak';
};

// @beta
export type TrackEncryptionBox = FullBox & {
    type: 'tenc';
    defaultIsEncrypted: number;
    defaultIvSize: number;
    defaultKid: number[];
};

// @beta
export type TrackExtendsBox = FullBox & {
    type: 'trex';
    trackId: number;
    defaultSampleDescriptionIndex: number;
    defaultSampleDuration: number;
    defaultSampleSize: number;
    defaultSampleFlags: number;
};

// @beta
export type TrackFragmentBaseMediaDecodeTimeBox = FullBox & {
    type: 'tfdt';
    baseMediaDecodeTime: number;
};

// @beta
export type TrackFragmentBox = ContainerBox<TrackFragmentHeaderBox | TrackFragmentBaseMediaDecodeTimeBox | TrackRunBox | SampleAuxiliaryInformationSizesBox | SampleAuxiliaryInformationOffsetsBox | SampleEncryptionBox> & {
    type: 'traf';
};

// @beta
export type TrackFragmentHeaderBox = FullBox & {
    type: 'tfhd';
    trackId: number;
    baseDataOffset?: number;
    sampleDescriptionIndex?: number;
    defaultSampleDuration?: number;
    defaultSampleSize?: number;
    defaultSampleFlags?: number;
};

// @beta
export type TrackFragmentRandomAccessBox = FullBox & {
    type: 'tfra';
    trackId: number;
    reserved: number;
    numberOfEntry: number;
    lengthSizeOfTrafNum: number;
    lengthSizeOfTrunNum: number;
    lengthSizeOfSampleNum: number;
    entries: TrackFragmentRandomAccessEntry[];
};

// @beta
export type TrackFragmentRandomAccessEntry = {
    time: number;
    moofOffset: number;
    trafNumber: number;
    trunNumber: number;
    sampleNumber: number;
};

// @beta
export type TrackHeaderBox = FullBox & {
    type: 'tkhd';
    creationTime: number;
    modificationTime: number;
    trackId: number;
    reserved1: number;
    duration: number;
    reserved2: number[];
    layer: number;
    alternateGroup: number;
    volume: number;
    reserved3: number;
    matrix: number[];
    width: number;
    height: number;
};

// @beta
export type TrackKindBox = FullBox & {
    type: 'kind';
    schemeUri: string;
    value: string;
};

// @beta
export type TrackReferenceBox = ContainerBox<TrackReferenceTypeBox> & {
    type: 'tref';
};

// @beta
export type TrackReferenceTypeBox = Box & {
    type: 'tref';
    trackIds: number[];
};

// @beta
export type TrackRunBox = FullBox & {
    type: 'trun';
    sampleCount: number;
    dataOffset?: number;
    firstSampleFlags?: number;
    samples: TrackRunSample[];
};

// @beta
export type TrackRunSample = {
    sampleDuration?: number;
    sampleSize?: number;
    sampleFlags?: number;
    sampleCompositionTimeOffset?: number;
};

// @alpha
export type TrackType = 'audio' | 'video' | 'text';

// @beta
export function trex(view: IsoView): Fields<TrackExtendsBox>;

// @beta
export function trun(view: IsoView): Fields<TrackRunBox>;

// @beta
export type TypeBox<T> = Box & {
    type: T;
    majorBrand: string;
    minorVersion: number;
    compatibleBrands: string[];
};

// @beta
export type TypedResult<T, D> = {
    type: T;
    data: D;
};

// @beta
export const UINT = "uint";

// @beta
export function unescapeHtml(text: string): string;

// @beta
export function url(view: IsoView): Fields<UrlBox>;

// @beta
export type UrlBox = FullBox & {
    type: 'url';
    location: string;
};

// @beta
export function urlToRelativePath(url: string, base: string): string;

// @beta
export function urn(view: IsoView): Fields<UrnBox>;

// @beta
export type UrnBox = FullBox & {
    type: 'urn';
    name: string;
    location: string;
};

// @beta
export const USABLE = "usable";

// @beta
export type UserDataBox = ContainerBox<Box> & {
    type: 'udta';
};

// @beta
export const UTF8 = "utf8";

// @beta
export function utf8ArrayToStr(array: Uint8Array, exitOnNull?: boolean): string;

// @beta
export const UTF_16 = "utf-16";

// @beta
export const UTF_8 = "utf-8";

// @beta
export function uuid(): string;

// @alpha
export function validatePresentation(presentation: Presentation): Validation;

// @alpha
export function validateSegment(segment: Segment, trackId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateSegments(segments: Segment[], trackId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateSelectionSet(selectionSet: SelectionSet, presentationId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateSelectionSets(selectionSets: SelectionSet[], presentationId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateSwitchingSet(switchingSet: SwitchingSet, selectionSetId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateSwitchingSets(switchingSets: SwitchingSet[], selectionSetId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateTrack(track: Track, switchingSetId?: string, prevValidation?: Validation): Validation;

// @alpha
export function validateTracks(tracks: Track[], switchingSetId?: string, prevValidation?: Validation): Validation;

// @alpha
export type Validation = {
    status: boolean;
    errorMessages: string[];
};

// @beta
export type ValueOf<T> = T[keyof T];

// @beta
export const VerboseLevel: {
    readonly ERROR: 0;
    readonly TEXT: 1;
    readonly WARNING: 2;
    readonly INFO: 2;
    readonly DEBUG: 3;
    readonly DATA: 3;
};

// @beta (undocumented)
export type VerboseLevel = ValueOf<typeof VerboseLevel>;

// @beta
export type VideoMediaHeaderBox = FullBox & {
    type: 'vmhd';
    graphicsmode: number;
    opcolor: number[];
};

// @alpha
export type VideoTrack = Track & {
    width: number;
    height: number;
    frameRate: FrameRate;
    par: string;
    sar: string;
    scanType: string;
};

// @beta
export type VisualSampleEntryBox<T extends 'avc1' | 'avc2' | 'avc3' | 'avc4' | 'hev1' | 'hvc1' | 'encv' = 'avc1' | 'avc2' | 'avc3' | 'avc4' | 'hev1' | 'hvc1' | 'encv'> = SampleEntryBox & {
    type: T;
    preDefined1: number;
    reserved2: number;
    preDefined2: number[];
    width: number;
    height: number;
    horizresolution: number;
    vertresolution: number;
    reserved3: number;
    frameCount: number;
    compressorName: number[];
    depth: number;
    preDefined3: number;
    config: Uint8Array;
};

// @beta
export function vlab(view: IsoView): Fields<WebVttSourceLabelBox>;

// @beta
export function vmhd(view: IsoView): Fields<VideoMediaHeaderBox>;

// @beta
export function vttC(view: IsoView): Fields<WebVttConfigurationBox>;

// @beta
export function vtte(): Fields<WebVttEmptySampleBox>;

// @beta
export const W3C_CLEAR_KEY_UUID = "1077efec-c0b2-4d02-ace3-3c1e52e2fb4b";

// @beta
export const WEBM = "webm";

// @beta
export type WebVttConfigurationBox = Box & {
    type: 'vttC';
    config: string;
};

// @beta
export type WebVttCue = {
    id: string;
    startTime: number;
    endTime: number;
    pauseOnExit: boolean;
    text: string;
    align: AlignSetting;
    region: WebVttRegion | null;
    vertical: DirectionSetting;
    snapToLines: boolean;
    line: LineAndPositionSetting;
    lineAlign: LineAlignSetting;
    position: LineAndPositionSetting;
    positionAlign: PositionAlignSetting;
    size: number;
};

// @beta
export type WebVttCueFactory = () => WebVttCue;

// @beta
export type WebVttCueIdBox = Box & {
    type: 'iden';
    cueId: string;
};

// @beta
export type WebVttCuePayloadBox = Box & {
    type: 'payl';
    cueText: string;
};

// @beta
export type WebVttCueResult = TypedResult<'cue', WebVttCue>;

// @beta
export type WebVttEmptySampleBox = Box & {
    type: 'vtte';
};

// @beta
export type WebVttErrorResult = TypedResult<'error', WebVttParsingError>;

// @beta
export class WebVttParser {
    constructor(options?: WebVttParserOptions);
    flush(): WebVttParser;
    oncue?: (cue: WebVttCue) => void;
    onflush?: () => void;
    onparsingerror?: (error: WebVttParsingError) => void;
    onregion?: (region: WebVttRegion) => void;
    onstyle?: (style: string) => void;
    ontimestampmap?: (timestampMap: TimestampMap) => void;
    parse(data?: string, reuseCue?: boolean): WebVttParser;
}

// @beta
export type WebVttParseResult = {
    cues: WebVttCue[];
    regions: WebVttRegion[];
    styles: string[];
    errors: WebVttParsingError[];
};

// @beta
export type WebVttParserOptions = {
    useDomTypes?: boolean;
    createCue?: WebVttCueFactory;
    createRegion?: WebVttRegionFactory;
};

// @beta
export class WebVttParsingError extends Error {
    constructor(message: string);
}

// @beta
export type WebVttRegion = {
    id: string;
    width: number;
    lines: number;
    regionAnchorX: number;
    regionAnchorY: number;
    viewportAnchorX: number;
    viewportAnchorY: number;
    scroll: ScrollSetting;
};

// @beta
export type WebVttRegionFactory = () => WebVttRegion;

// @beta
export type WebVttRegionResult = TypedResult<'region', WebVttRegion>;

// @beta
export type WebVttResult = WebVttCueResult | WebVttRegionResult | WebVttTimestampMapResult | WebVttStyleResult | WebVttErrorResult;

// @beta
export const WebVttResultType: {
    readonly CUE: "cue";
    readonly REGION: "region";
    readonly TIMESTAMP_MAP: "timestampmap";
    readonly STYLE: "style";
    readonly ERROR: "error";
};

// @beta (undocumented)
export type WebVttResultType = ValueOf<typeof WebVttResultType>;

// @beta
export type WebVttSettingsBox = Box & {
    type: 'sttg';
    settings: string;
};

// @beta
export type WebVttSourceLabelBox = Box & {
    type: 'vlab';
    sourceLabel: string;
};

// @beta
export type WebVttStyleResult = TypedResult<'style', string>;

// @beta
export type WebVttTimestampMapResult = TypedResult<'timestampmap', TimestampMap>;

// @beta
export class WebVttTransformer {
    constructor();
    flush(controller: TransformStreamDefaultController<WebVttResult>): void;
    transform(chunk: string, controller: TransformStreamDefaultController<WebVttResult>): void;
}

// @beta
export class WebVttTransformStream extends TransformStream<string, WebVttResult> {
    constructor(writableStrategy?: QueuingStrategy<string>, readableStrategy?: QueuingStrategy<WebVttResult>);
}

// @beta
export const WIDEVINE_KEY_SYSTEM = "com.widevine.alpha";

// @beta
export const WIDEVINE_UUID = "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";

// @beta
export const WidevineRobustness: {
    readonly SW_SECURE_CRYPTO: typeof SW_SECURE_CRYPTO;
    readonly SW_SECURE_DECODE: typeof SW_SECURE_DECODE;
    readonly HW_SECURE_CRYPTO: typeof HW_SECURE_CRYPTO;
    readonly HW_SECURE_DECODE: typeof HW_SECURE_DECODE;
    readonly HW_SECURE_ALL: typeof HW_SECURE_ALL;
};

// @beta
export type WidevineRobustness = ValueOf<typeof WidevineRobustness>;

// @beta
export type XmlNode = {
    nodeName: string;
    nodeValue: string | null;
    attributes: Record<string, string>;
    childNodes: XmlNode[];
    prefix?: string | null;
    localName?: string;
};

// @beta
export type XmlParseOptions = {
    pos?: number;
    keepWhitespace?: boolean;
    keepComments?: boolean;
};

// @beta
export class ZlemaEstimator implements ThroughputEstimator {
    // (undocumented)
    getEstimate(): number;
    // (undocumented)
    sample(sample: ResourceTiming): void;
}

```
